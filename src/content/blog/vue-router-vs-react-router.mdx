---
title: "Vue Router vs React Router"
date: "2025-12-17"
description: "Preparing related knowledge for job interview"
tags: ["Interview", "Vue / React Comparison"]
cover: "/og/hello-mdx.png"
category: "Vue / React Comparison"
---

****

## Vue Router

```vue  
<template>
  <h1>Hello App!</h1>
  <p><strong>Current route path:</strong> {{ $route.fullPath }}</p>
  <nav>
    <RouterLink to="/">Go to Home</RouterLink>
    <RouterLink to="/about">Go to About</RouterLink>
  </nav>
  <main>
    <RouterView />
  </main>
</template>
```

```javascript
import { createMemoryHistory, createRouter } from 'vue-router'

import HomeView from './HomeView.vue'
import AboutView from './AboutView.vue'

const routes = [
  { path: '/', component: HomeView },
  { path: '/about', component: AboutView },
]

export const router = createRouter({
  history: createMemoryHistory(),
  routes,
})
```

If you're curious about what this plugin does, some of its responsibilities include:

1. Globally registering the RouterView and RouterLink components.
2. Adding the global $router and $route properties.
3. Enabling the useRouter() and useRoute() composables.
4. Triggering the router to resolve the initial route.

```javascript
import User from './User.vue'

// these are passed to `createRouter`
const routes = [
  // dynamic segments start with a colon
  { path: '/users/:id', component: User },
]
```

Regular params will only match characters in between url fragments, separated by /. If we want to match anything, we can use a custom param regexp by adding the **regexp** inside parentheses right after the param:

```javascript
const routes = [
  // will match everything and put it under `route.params.pathMatch`
  { path: '/:pathMatch(.*)*', name: 'NotFound', component: NotFound },
  // will match anything starting with `/user-` and put it under `route.params.afterUser`
  { path: '/user-:afterUser(.*)', component: UserGeneric },
]
```

If you need to match routes with multiple sections like /first/second/third, you should mark a param as repeatable with * (0 or more) and + (1 or more):

```javascript
const routes = [
  // /:chapters -> matches /one, /one/two, /one/two/three, etc
  { path: '/:chapters+' },
  // /:chapters -> matches /, /one, /one/two, /one/two/three, etc
  { path: '/:chapters*' },
]
```

You can also mark a parameter as optional by using the ? modifier (0 or 1):

```javascript
const routes = [
  // will match /users and /users/posva
  { path: '/users/:userId?' },
  // will match /users and /users/42
  { path: '/users/:userId(\\d+)?' },
]
```

Using a name has various advantages:

- No hardcoded URLs.
- Automatic encoding of params.
- Avoids URL typos.
- Bypassing path ranking, e.g. to display a lower-ranked route that matches the same path.

```javascript
const routes = [
  {
    path: '/user/:username',
    name: 'profile', 
    component: User
  }
]
```
```vue
<router-link :to="{ name: 'profile', params: { username: 'erina' } }">
  User profile
</router-link>
```

### Nested Routes

```javascript
const routes = [
  {
    path: '/user/:id',
    component: User,
    children: [
      {
        // UserProfile will be rendered inside User's <router-view>
        // when /user/:id/profile is matched
        path: 'profile',
        component: UserProfile,
      },
      {
        // UserPosts will be rendered inside User's <router-view>
        // when /user/:id/posts is matched
        path: 'posts',
        component: UserPosts,
      },
    ],
  },
]
```
```javascript
const routes = [
  {
    path: '/admin',
    children: [
      { path: '', component: AdminOverview },
      { path: 'users', component: AdminUserList },
      { path: 'users/:id', component: AdminUserDetails },
    ], 
  },
]
```

Similar to **window.history.go(n)**:
```javascript
// go forward by one record, the same as router.forward()
router.go(1)

// go back by one record, the same as router.back()
router.go(-1)

// go forward by 3 records
router.go(3)

// fails silently if there aren't that many records
router.go(-100)
router.go(100)
```

You may have noticed that **router.push**, **router.replace** and **router.go** are counterparts of **window.history.pushState**, **window.history.replaceState** and **window.history.go**, and they do imitate the **window.history** APIs.

Redirecting is also done in the routes configuration. To redirect from /home to /:
```javascript
const routes = [{ path: '/home', redirect: '/' }]
```  

We can remove the direct dependency on **$route** in **User.vue** by declaring a prop instead:
```vue
<!-- User.vue -->
<script setup>
defineProps({
  id: String
})
</script>

<template>
  <div>
    User {{ id }}
  </div>
</template>
```
```javascript
const routes = [
  { path: '/user/:id', component: User, props: true }
]
```
This allows you to use the component anywhere, which makes the component easier to reuse and test.

The RouterLink component has two props, **activeClass** and **exactActiveClass**, that can be used to change the names of the classes that are applied:
```vue
<RouterLink
  activeClass="border-indigo-500"
  exactActiveClass="border-indigo-700"
  ...
>
``` 
The default class names can also be changed globally by passing the **linkActiveClass** and **linkExactActiveClass** options to **createRouter()**:
```javascript
const router = createRouter({
  linkActiveClass: 'border-indigo-500',
  linkExactActiveClass: 'border-indigo-700',
  // ...
})
```

### Different History modes
- HTML5 Mode: The HTML5 mode is created with **createWebHistory()** and is the recommended mode.
- Hash Mode: The hash history mode is created with **createWebHashHistory()**.
- Memory mode: The memory history mode doesn't assume a browser environment and therefore doesn't interact with the URL nor automatically triggers the initial navigation. This makes it perfect for Node environment and SSR. It is created with **createMemoryHistory()** and requires you to push the initial navigation after calling app.use(router).



****

## React Router

Routes are configured in **app/routes.ts**. Each route has two required parts: a URL pattern to match the URL, and a file path to the route module that defines its behavior.

```typescript
route("teams/:teamId", "./team.tsx"),
//           route module ^^^^^^^^
```

### Nested Routes
Routes can be nested inside parent routes.

```typescript
import {
  type RouteConfig,
  route,
  index,
} from "@react-router/dev/routes";

export default [
  // parent route
  route("dashboard", "./dashboard.tsx", [
    // child routes
    index("./home.tsx"),
    route("settings", "./settings.tsx"),
  ]),
] satisfies RouteConfig;
```

Child routes are rendered through the `<Outlet/>` in the parent route.

```tsx
import { Outlet } from "react-router";

export default function Dashboard() {
  return (
    <div>
      <h1>Dashboard</h1>
      {/* will either be home.tsx or settings.tsx */}
      <Outlet />
    </div>
  );
}
```

### Layout Routes
Using layout, layout routes create new nesting for their children, but they don't add any segments to the URL. It's like the root route but they can be added at any level.

```typescript
import {
  type RouteConfig,
  route,
  layout,
  index,
  prefix,
} from "@react-router/dev/routes";

export default [
  layout("./marketing/layout.tsx", [
    index("./marketing/home.tsx"),
    route("contact", "./marketing/contact.tsx"),
  ]),
  ...prefix("projects", [
    index("./projects/home.tsx"),
    layout("./projects/project-layout.tsx", [
      route(":pid", "./projects/project.tsx"),
      route(":pid/edit", "./projects/edit-project.tsx"),
    ]),
  ]),
] satisfies RouteConfig;
```

### Index Routes
Index routes render into their parent's Outlet at their parent's URL (like a default child route).

```typescript
import {
  type RouteConfig,
  route,
  index,
} from "@react-router/dev/routes";

export default [
  // renders into the root.tsx Outlet at /
  index("./home.tsx"),
  route("dashboard", "./dashboard.tsx", [
    // renders into the dashboard.tsx Outlet at /dashboard
    index("./dashboard-home.tsx"),
    route("settings", "./dashboard-settings.tsx"),
  ]),
] satisfies RouteConfig;
```

### Route Prefixes
Note that this does not introduce a new route into the route tree. Instead, it merely modifies the paths of its children.

For example, these two sets of routes are equivalent:
```typescript
// This usage of `prefix`...
prefix("parent", [
  route("child1", "./child1.tsx"),
  route("child2", "./child2.tsx"),
])

// ...is equivalent to this:
[
  route("parent/child1", "./child1.tsx"),
  route("parent/child2", "./child2.tsx"),
]
```

### Dynamic Segments
If a path segment starts with : then it becomes a "dynamic segment". When the route matches the URL, the dynamic segment will be parsed from the URL and provided as params to other router APIs.

```typescript
route("teams/:teamId", "./team.tsx"),
```

```typescript
import type { Route } from "./+types/team";

export async function loader({ params }: Route.LoaderArgs) {
  //                           ^? { teamId: string }
}

export default function Component({
  params,
}: Route.ComponentProps) {
  params.teamId;
  //        ^ string
}

```

You can have multiple dynamic segments in one route path:
```typescript
route("c/:categoryId/p/:productId", "./product.tsx"),
```

```typescript
import type { Route } from "./+types/product";

async function loader({ params }: LoaderArgs) {
  //                    ^? { categoryId: string; productId: string }
}
```

### Optional Segments
```typescript
route(":lang?/categories", "./categories.tsx");
route("users/:userId/edit?", "./user.tsx");
```

### Splats
Also known as "catchall" and "star" segments. If a route path pattern ends with /* then it will match any characters following the /, including other / characters.

```typescript
route("files/*", "./files.tsx"),
```

```typescript
export async function loader({ params }: Route.LoaderArgs) {
  // params["*"] will contain the remaining URL after files/
}
```

You can destructure the *, you just have to assign it a new name. A common name is splat:
```typescript
const { "*": splat } = params;
```

You can also use a splat to catch requests that don't match any route:
```typescript
route("*", "./catchall.tsx"); // catchall route,
```
```typescript
export function loader() {
  throw new Response("Page not found", { status: 404 });
}
```

****

## Reference
- [Vue Router](https://router.vuejs.org/guide/)
- [React Router](https://reactrouter.com/)
