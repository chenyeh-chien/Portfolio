---
title: "Common UI Library"
date: "2025-12-15"
description: ""
tags: ["UI", "Library", "React", "Vue", "Angular", "Svelte"]
cover: "/og/hello-mdx.png"
category: "Front-end Architecture"
---

****
### Monorepo（大倉庫架構）
適用場景： 這些專案都在同一個開發團隊手中，且會頻繁同步開發。

在 Monorepo 裡，你的元件庫與各個應用程式（App）並排存在。
- 技術棧： pnpm workspaces + Turborepo。
- 目錄結構：
```
/my-monorepo
├── apps/
│   ├── admin-system/    (React 專案 A)
│   └── user-portal/     (React 專案 B)
├── packages/
│   ├── ui/              (共用元件庫 - React)
│   └── config/          (共用 ESLint/Tailwind 配置)
└── package.json
```
- 自動化邏輯：
    - 在專案 A 的 package.json 直接寫入 "@my-org/ui": "workspace:*"。
    - 更新方式： 當你修改 /packages/ui 的代碼後，由於是符號連結（Symlink），專案 A 和 B 會即時看到更新，完全不需要執行 npm install。
    - 構建優化： Turborepo 會快取已編譯的元件，確保開發速度。

### Private npm Registry + Semantic Release
適用場景： 專案分散在不同倉庫，或者不同專案由不同小組維護，需要嚴格的版本穩定性。
- 技術棧： Github Packages (或 Verdaccio) + Changesets。
- 自動化流程：
    1. 開發： 在獨立的 ui-library 倉庫開發。
    2. 版本控制： 使用 Changesets 工具。當你完成修改並提交 PR 時，它會要求你記錄這次改動是 patch、minor 還是 major。
    3. CI/CD 自動發佈：
      - PR 合併到 main 分支。
      - GitHub Action 自動執行 npm publish，將新版本（例如 v1.2.0）推送到私有倉庫。
    4. 專案端更新：
      - 專案 A 收到通知（或透過 Dependabot 提醒）。
      - 執行 npm update @my-org/ui 即可獲得最新元件。

****
### 如何確保元件庫「好用」且「不會被改壞」？
不論你選擇哪種方案，資深工程師在維護元件庫時必須建立以下機制：

#### 1. Storybook (視覺化文檔)
這是元件庫的門面。你必須為每個元件撰寫 *.stories.tsx。
- 好處： 開發專案的人不需要看源碼，直接在 Storybook 頁面上就能操作元件的 Props，看它長什麼樣子。

#### 2. Tailwind CSS 的策略
在元件庫使用 Tailwind 時，最怕跟專案的樣式衝突。
- 做法： 在元件庫中將 Tailwind 樣式打包，或者在專案的 tailwind.config.js 中將元件庫的路徑加入 content 陣列，確保樣式被正確掃描並生成。

#### 3. 自動化視覺測試 (Chromatic)
當你更新了元件庫的一個 Button 樣式，你怎麼知道會不會導致「專案 B」的某個頁面跑版？
- 工具： Chromatic。
- 邏輯： 每次 PR 時，它會自動幫你對所有元件截圖，並與舊版本對比。如果有 1 像素的偏移，它會攔截 PR 並要求你審核。